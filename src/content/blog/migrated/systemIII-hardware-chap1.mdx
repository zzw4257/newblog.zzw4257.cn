---
title: 计算机系统 III 硬件部分：系统贯通与层次抽象
description: 本文介绍计算机系统 III 硬件部分的核心理念——"带走你自己的系统"，包括计算机系统的抽象层次、系统贯通方法、理论层次与实验实现的映射，以及系统能力的重要性，是系统课程的基础入门。
pubDate: 2025-09-15T12:00:00.000Z
image: /images/uploads/curricular-iii-chap1-cover.jpg
badge: Course
draft: false
categories:
  - System III
  - Course Notes
tags:
  - 计算机系统
  - RISC-V
  - CPU设计
  - 系统贯通
  - 课程笔记
---

> **[迁移说明]** 本文最初发布于 `blog.zzw4257.cn`，现已迁移并在本站进行结构化整理与增强。

# 计算机系统 III 硬件部分引言章

## 引言：你将从这门课程中带走什么？

“计算机系统 III”（及其前序课程）的核心理念是让学生能够 **“带走你自己的系统”**。这不仅仅是理论知识，更是从头开始设计、构建和理解计算机系统的实践能力。

> **✅ 核心收获**  
> **严肃地说，你将带走你自己的系统。** 这意味着构建你自己的 CPU 并在其上运行你自己的操作系统。

课程的高潮是 “ZJUSYS 系统贯通课程”，学生在此展示他们能够：

* 设计一个64位 RISC-V 五级流水线 CPU。
* 实现分支预测、特权级（Supervisor, User）、异常处理、MMU（Sv39 虚拟内存）和 I/O 等功能。
* 在他们自己设计的 CPU 上运行一个定制的简单操作系统。
* 为他们的操作系统添加用户态进程、系统调用和 I/O 功能。

---

## I. 宏伟蓝图：计算机系统的层次

理解计算机系统涉及到揭开一层层的抽象，从高层次的问题一直到底层电子的基本行为。

> **💬 大卫·惠勒 (David Wheeler)**  
> "计算机科学中的任何问题都可以通过增加一个间接的中间层来解决。"

**抽象层次：**

1. **问题 (Problem):** 需要解决的高层次任务。
2. **算法 (Algorithm):** 解决问题的分步过程。
3. **程序 (Program):** 用编程语言（如 C 语言）实现的算法。
4. **运行时系统 (Runtime System - VM, OS, MM):** 为程序管理资源并提供服务的软件（例如：操作系统、虚拟机、内存管理）。
   * **操作系统 (OS):** 管理硬件、进程、内存、文件等。
5. **指令集架构 (Instruction Set Architecture - ISA):** 硬件和软件之间的接口。定义指令、寄存器、内存寻址等（例如：RISC-V）。
6. **微架构 (Microarchitecture):** ISA 的具体硬件实现（例如：流水线级数、缓存组织、分支预测器设计）。
7. **逻辑门级 (Logic - Gate Level):** 使用逻辑门（与门、或门、非门、异或门等）实现。
8. **电路晶体管级 (Circuits - Transistor Level):** 使用晶体管和其他电子元件实现。
9. **电子物理层 (Electrons - Physics):** 基本的物理现象。

> **ℹ️ 计算机系统III的重点**  
> 本课程主要关注具有挑战性的层次：
> 
> *   **运行时系统 (VM, OS, MM)**
> *   **ISA (架构)**
> *   **微架构**
> *   **逻辑门级**

### 系统能力的重要性

* **计算机科学与技术 (《计算教育学科规范2020》 Computing Curricula 2020):**
  * 系统能力: 75% (系统设计能力: 23%, 系统开发能力: 28%, 系统应用能力: 17%, 系统认知能力: 7%)
* **网络安全/信息安全 (CSEC 2017, Cyber2yr 2020):**
  * **系统安全 (System Security)** 是核心和基础组成部分，连接硬件、软件、数据、网络、人员和组织安全等方面。

---

## II. 构建你的系统：“系统贯通”方法

课程结构可能涉及在“计算机系统 I、II、III”中构建日益复杂的系统。

### A. 理论层次 vs. 实验实现

幻灯片 (幻灯片 10-15) 展示了理论知识如何映射到实际的实验工作。

#### 系统层次演进 (理论)：

* **系统1 (基础):**
  * **硬件:** 基础 CPU (PC, ALU, 寄存器组, 控制器), 存储器 (Memory), 磁盘 (Disk), I/O 设备。
  * **概念:** ISA (RISC-V), 程序执行的基本原理, 单周期与冯诺依曼架构。
  * **软件:** 编译器, 解释器, 基础操作系统 (OS)。
  * **电路:** 数值表示与门电路, 组合逻辑电路, 时序逻辑电路, 基本运算电路, 计算机硬件组成 (硬件模块设计)。
* **系统2 (流水线与基础OS):**
  * **硬件:** 流水线 CPU (含冒险检测, 中断控制, 转发单元 (Forwarding Unit), CSRs), 总线 (BUS)。
  * **概念:** 软硬件协同 (OS加载), 流水线实现与性能分析, 流水线冲突与处理, 进程管理 (进程调度, 进程通信, CPU调度, 同步、互斥、死锁), 中断与时钟。
* **系统3 (高级CPU与OS):**
  * **硬件:** 高级流水线 CPU (含分支预测单元 BPU, 高速缓存 Cache, 内存管理单元 MMU/TLB, 重排序缓冲 ROB, 保留站 RS, 寄存器别名表 RAT)。
  * **概念:** 定量分析方法 (ILP, DLP, TLP), 虚拟存储器设计, Cache设计与性能分析, 内存管理 (主存, 虚拟内存), 存储管理 (设备管理, 文件系统, 磁盘管理)。

#### “系统贯通实验”结构：

* **系统1 实验 (基础):**
  * **重点:** Verilog 语言, 组合逻辑电路 (多路选择器/七段数码管, 加法器), 时序逻辑电路 (有限状态机/乘法器, 计数器), 单周期 CPU (SCPU 数据通路, SCPU 控制单元), RISC-V 指令集与汇编。
  * **工具:** Vivado, Verilator, FPGA。
* **系统2 实验 (流水线与基础内核):**
  * **重点:** 流水线 CPU (Pipeline 基础/阶段寄存器, 冒险处理 Forwarding 技术), AXI4-Lite 总线模型与使用, CSR寄存器/中断与异常处理。
  * **OS 概念:** 内核启动逻辑与运行, 内核线程管理与调度, RISC-V 时钟中断处理, (可能涉及) 虚拟化技术。
  * **软硬件协同综合。**
* **系统3 实验 (高级CPU与用户态OS):**
  * **重点:** 高级流水线 CPU (基于 BHT/BTB 的动态分支预测, 内存 Cache 设计, 内存管理单元 MMU 虚拟地址转换)。
  * **OS 概念 (虚拟化):** SV39 分页/虚拟内存管理, 用户态进程实现与用户态切换, 缺页异常处理与 fork 机制。
  * **软硬件协同综合。**

### B. ZJV 项目：浙江大学 RISC-V 的探索

“ZJV” 代表 **浙江大学 (ZheJiang University) + RISC-V**。这个项目展示了课程的实践成果。

* **Amipsel (ZJV 1.0 微架构 - 学生示例):**
  * **特性:** 五段流水32位处理器，高度可配置性 (前端单/双发射，后端最多为三发射)，TLB，原子指令等。使用 Chisel 语言开发。
  * **微架构组件:** I-Cache, I-MMU, D-MMU, D-Cache, L2 Cache, Mem Crossbar, MMIO Crossbar, Clint, Plic, UART, Flash。
  * **流水线阶段:** IF, ID, EXE, MEM, WB，以及各种功能单元。
  * **测试:** 自主搭建的差分测试框架 dtqemu，模拟 RAM 和串口等外设，同步中断，对比 qemu 和 AMipsel 的寄存器，便捷 Linux 的调试。操作系统移植，支持 pmon 的全部指令运行，支持 ucore 的运行，完成 Linux 的启动流程到用户态。
  * **成就:** “龙芯杯”竞赛一等奖。
* **ZJV 流片成果 (“一生一芯” 项目):**
  * ZJV 1.0: 一期成果。
  * ZJV 2.0 (星空 StarrySky): 三期成果，搭载学生自制 CPU 的 RV64 单板计算机。
* **高级 ZJV 系统 (CPU + 系统):**
  * **特性:** 自主设计优化，获得1789性能分；面向通用系统，启动 Linux 发行版；着眼安全特性，保护数据完整性和机密性。
  * **指令集支持:** 裁剪指令 (BL, soft float 等)，TLB 相关指令 (TLBP, TLBR, TLBWI, TLBWR 等)，原子指令 (LL, SC)，其他功能指令 (MOVN, MADD, LWL, TGE, CLZ, CLO 等)，协处理器0 (EntryHi, EntryLo, Context, Index, Ebase 等)。
  * **OS 启动:** 通过 PMON 加载 uCore、Linux 操作系统并启动。
  * **成就:** “逐梦杯”总决赛冠军，多次“龙芯杯”奖项。
* **ZJV 项目时间线:**| 日期    | 里程碑                              | 备注 |
  | :------ | :---------------------------------- | :--- |
  | 2020.12 | 第一次投片 (ZJV 1.0)                |      |
  | 2021.08 | 龙芯杯一等奖 (性能第一名) (Amipsel) |      |
  | 2021.12 | ZJV 2.0投片, ZJV 1.0第二次投片      |      |
  | 2022    | 逐梦杯全国冠军                      |      |
  | 2022.08 | 龙芯杯二等奖 (团队赛，性能第一名)   |      |
  | 2022.08 | 龙芯杯个人赛一等奖                  |      |
  | 2023.08 | 龙芯杯个人赛一等奖                  |      |
  | 2024.04 | ZJV 2.0回片, ZJV 1.0回片            |      |
  | 2024.12 | ZJV 浙大安全芯, 求是I号投片 (计划)  |      |

---

## III. 第一章：计算机系统基础

### §1.1 引论

#### 冯诺依曼结构 (Von Neumann Structure)

* **核心原则:** 数据和程序（指令）存储在同一个存储器中。
* **操作:** CPU 从存储器中获取指令和数据，执行操作，并将结果存回存储器。
* **组件:**
  * **输入设备 (Input):** 向系统提供数据。
  * **输出设备 (Output):** 展示系统结果。
  * **存储器 (Memory):** 存储程序和数据。
  * **中央处理器 (CPU):**
    * **控制器 (Controller):** 指挥操作。
    * **运算器 (Arithmetic Logic Unit - ALU):** 执行计算。
  * **外存储器 (Storage):** 长期、非易失性存储。
* **路径:**
  * **数据通路 (Data path):** 在组件之间传输数据。
  * **控制通路 (Control path):** 从控制器传输控制信号。

#### 计算机革命 (The Computer Revolution)

* 由计算机技术的进步驱动（以 **摩尔定律** 为基础）。
* 催生了新的应用：汽车中的计算机、手机、人类基因组计划、万维网、搜索引擎、大语言模型 (LLM)。
* 计算机无处不在。

#### 你将如何学习？

* **可能性:** 站在巨人的肩膀上。
* **重点:** 概念、思想和原理。
* **方法:** 定量方法。
* **目标:** 抓住问题本质，找到正确的解决方法。
* **努力:** “一分耕耘，一分收获。” (As a man sows, so he shall reap.)

### §1.2 计算机的分类

计算机可以通过多种方式分类。

#### 费林分类法 (Flynn's Taxonomy - 基于指令流和数据流)

* **SISD (Single Instruction, Single Data - 单指令流单数据流):** 传统单处理器。
  * `CU -> PU -> MM`
* **SIMD (Single Instruction, Multiple Data - 单指令流多数据流):** 向量处理器、GPU。
  * `CU -> PU1, PU2...PUn -> MM1, MM2...MMm` (多个 PU 对不同数据执行相同指令)。
* **MISD (Multiple Instruction, Single Data - 多指令流单数据流):** 实践中罕见（例如，某些容错系统、脉动阵列）。
  * `CU1 -> PU1 -> CU2 -> PU2 ... -> MM` (数据流经一系列处理器)。
* **MIMD (Multiple Instruction, Multiple Data - 多指令流多数据流):** 大多数现代多核处理器、分布式系统。
  * 多个 CU 和 PU 独立操作于不同的数据流。

#### 其他分类：

* **台式计算机 (Desktop computers / Personal Computers):** 通用型，软件种类繁多，相对较低成本下为单个用户提供良好性能。
* **服务器计算机 (Server computers):** 强调为少数复杂应用提供卓越性能，或为许多用户提供可靠性能。具有更大的计算、存储或网络容量。
* **嵌入式计算机 (Embedded computers):** 数量最多、种类最繁杂的类别。作为系统组件隐藏其中（例如，在汽车、家电中）。有严格的功耗、性能和成本限制。
* **个人移动设备 (Personal Mobile Devices - PMDs):** 智能手机、平板电脑。与 PC 的设计要求相似，但功耗限制极为严格。
* **超级计算机 (Supercomputer):** 性能最高，通常是计算机集群。高容量、高性能、高可靠性。规模从机架大小到建筑大小不等。

### 你将学到什么 (课程目标回顾)

* 程序如何被翻译成机器语言。
* 硬件如何执行这些指令。
* 硬件/软件接口 (ISA)。
* 什么决定了程序性能以及如何改进它。
* 硬件设计者如何提高性能。
* 什么是并行处理。

---

## IV. 性能 (Performance)

### §1.3 定义和衡量性能

性能是计算机系统中的关键。

#### 定义性能

* “哪架飞机的性能最好？” 取决于衡量标准：
  * 载客量 (Passenger Capacity)
  * 巡航里程 (Cruising Range)
  * 巡航速度 (Cruising Speed)
  * 乘客数 × 英里/小时 (Passengers * mph - 吞吐量)
* 对于计算机，常见的衡量标准是：
  * **响应时间 (Response Time / Latency / Elapse Time - 延迟/耗时):** 事件开始和完成之间的时间。完成一项任务需要多长时间。对单个用户至关重要。
  * **吞吐量 (Throughput):** 在给定时间内完成的总工作量。对大数据/服务器工作负载至关重要（例如，每小时的任务数/事务数）。

#### 影响性能的因素

* **算法:** 决定执行操作的数量。
* **编程语言、编译器、体系结构 (ISA):** 决定每个操作对应的机器指令数量。
* **处理器和存储系统:** 决定指令执行的速度。
* **I/O 系统 (包括 OS):** 决定 I/O 操作的速度。

#### 执行时间 (Execution Time)

* **响应时间 (Elapsed Time - 耗时):** 总时间，包括处理、I/O、操作系统开销、空闲时间。决定了整体系统性能。
* **CPU 时间 (Execution Time - 执行时间):** CPU 用于处理给定作业的时间。
  * 不包括 I/O 时间、其他作业的份额。
  * 包括：
    * **用户 CPU 时间 (User CPU Time):** CPU 花费在*程序本身*的时间。
    * **系统 CPU 时间 (System CPU Time):** CPU 花费在*操作系统中，代表程序执行任务*的时间。

> **✅ 性能定义**
    **性能 = 1 / 执行时间**
    “X 比 Y 快 *n* 倍” 意味着：
    性能`<sub>`X`</sub>` / 性能`<sub>`Y`</sub>` = 执行时间`<sub>`Y`</sub>` / 执行时间`<sub>`X`</sub>` = *n*

### §1.4 性能的定量方法

#### CPU 性能公式

* **CPU 执行时间 = CPU 时钟周期数 × 时钟周期时间**
* **CPU 执行时间 = CPU 时钟周期数 / 时钟频率 (Clock Rate)**

  * **时钟周期时间 (Clock Cycle Time):** 一个时钟周期的持续时间 (例如, 250ps = 0.25ns = 250 × 10`<sup>`-12`</sup>`s)。
  * **时钟频率 (Clock Rate / Frequency):** 每秒的周期数 (例如, 4.0GHz = 4000MHz = 4.0 × 10`<sup>`9`</sup>`Hz)。
  * **时钟周期时间 = 1 / 时钟频率**
* **提高性能：**

  * 减少时钟周期数。
  * 提高时钟频率（减少时钟周期时间）。
  * 通常需要在时钟频率和周期数之间进行权衡。

#### 指令数 (IC) 和 每指令周期数 (CPI)

* **指令数 (Instruction Count - IC):** 程序执行的指令数量。由程序、ISA 和编译器决定。
* **每指令周期数 (Cycles Per Instruction - CPI):** 每条指令平均需要的时钟周期数。由 CPU 硬件决定。
  * 如果不同类型的指令有不同的 CPI：
    `时钟周期数 = Σ (CPI_i × IC_i)` (对每类指令 *i* 求和)。
  * **加权平均 CPI = 总时钟周期数 / 总指令数**
    `CPI = Σ (CPI_i × (IC_i / 总IC))` 其中 `(IC_i / 总IC)` 是指令类别 *i* 的相对频率。

> **✅ 核心公式：CPU 时间**
    **CPU 时间 = 指令数 (IC) × CPI × 时钟周期时间**
    **CPU 时间 = (指令数 (IC) × CPI) / 时钟频率**

    **性能取决于：**
    *   **算法:** 影响 IC，可能影响 CPI。
    *   **编程语言:** 影响 IC, CPI。
    *   **编译器:** 影响 IC, CPI。
    *   **指令集架构 (ISA):** 影响 IC, CPI, 时钟周期时间 (T`<sub>`c`</sub>`)。

#### 多处理器 (Multiprocessors)

* **多核微处理器 (Multicore microprocessors):** 每个芯片上有一个以上的处理器。
* 需要**显式并行编程 (explicitly parallel programming)**。
  * 不同于指令级并行 (ILP)，ILP 中硬件同时执行多条指令，对程序员透明。
  * 挑战：为性能编程、负载均衡、优化通信和同步。

#### 阿姆达尔定律 (Amdahl's Law)

> **📖 阿姆达尔定律**
    通过使用某种更快的执行模式所能获得的性能提升，受限于该更快模式可被使用的时间比例。**重点优化常用部分 (Make the common case fast!)**

* **取决于两个因素：**

  1. **增强部分占比 (Fraction`<sub>`enhanced`</sub>`):** （原始系统）执行时间中可以被增强改进的部分所占的比例。(总是 ≤ 1)。
  2. **增强带来的加速比 (Speedup`<sub>`enhanced`</sub>`):** 增强部分自身变快了多少倍。(总是 > 1)。
* **整体加速比公式：**
  `新执行时间 = (旧执行时间 × (1 - Fraction_enhanced)) + (旧执行时间 × Fraction_enhanced / Speedup_enhanced)`
  **整体加速比 (Speedup`<sub>`overall`</sub>`) = 旧执行时间 / 新执行时间**
  **Speedup`<sub>`overall`</sub>` = 1 / [ (1 - Fraction`<sub>`enhanced`</sub>`) + (Fraction`<sub>`enhanced`</sub>` / Speedup`<sub>`enhanced`</sub>`) ]**
* **重要推论：**
  **Speedup`<sub>`overall`</sub>` < 1 / (1 - Fraction`<sub>`enhanced`</sub>`)**
  这意味着即使增强部分的性能提升到无限快 (Speedup`<sub>`enhanced`</sub>` → ∞)，整体加速比也受限于无法增强的那部分任务。

> **📝 阿姆达尔定律示例1**
    一个函数占用了程序执行时间的 40%。如果这个函数的速度提高了20倍，那么整个系统的整体加速比是多少？
    *   Fraction`<sub>`enhanced`</sub>` = 0.4
    *   Speedup`<sub>`enhanced`</sub>` = 20
    *   Speedup`<sub>`overall`</sub>` = 1 / [ (1 - 0.4) + (0.4 / 20) ] = 1 / [ 0.6 + 0.02 ] = 1 / 0.62 ≈ 1.613

> **📝 阿姆达尔定律示例2**
    浮点运算速度提高了20倍。这使得某个程序的整体性能提高了5倍。那么浮点运算在原始执行时间中占多大比例？
    *   Speedup`<sub>`overall`</sub>` = 5
    *   Speedup`<sub>`enhanced`</sub>` = 20
    *   令 F = Fraction`<sub>`enhanced`</sub>`
    *   5 = 1 / [ (1 - F) + (F / 20) ]
    *   1/5 = (1 - F) + F/20
    *   0.2 = 1 - F + 0.05F
    *   0.2 = 1 - 0.95F
    *   0.95F = 0.8
    *   F = 0.8 / 0.95 ≈ 0.842 即 84.2%

#### 衡量数据大小

* 位 (bit): 二进制数字
* 半字节 (nibble): 4 位
* 字节 (byte): 8 位
* 字 (word): 通常是 32 位 (4 字节) 或 64 位 (8 字节)
* KiB (kibibyte) / KB (kilobyte): 2`<sup>`10`</sup>` = 1,024 字节
* MiB (mebibyte) / MB (megabyte): 2`<sup>`20`</sup>` = 1,048,576 字节
* GiB (gibibyte) / GB (gigabyte): 2`<sup>`30`</sup>` 字节
* TiB (tebibyte) / TB (terabyte): 2`<sup>`40`</sup>` 字节
* PiB (pebibyte) / PB (petabyte): 2`<sup>`50`</sup>` 字节

---

## V. §1.5 计算机体系结构的伟大思想

这些是几十年来驱动计算机设计的8个基本思想：

1. **为摩尔定律而设计 (Design for Moore's Law):**
   * 芯片上的晶体管数量大约每18-24个月翻一番。
   * 架构师必须预测系统设计完成时的技术能力。
2. **使用抽象简化设计 (Use Abstraction to Simplify Design):**
   * 在不同层次上表示设计，隐藏底层细节以管理复杂性。
3. **重点优化常用部分 (Make the Common Case Fast):** (与阿姆达尔定律相关)
   * 识别程序/系统中频繁执行的部分并对其进行优化。
4. **通过并行提高性能 (Performance via Parallelism):**
   * 通过同时执行操作来提高性能（例如，指令级、线程级、进程级并行）。
5. **通过流水线提高性能 (Performance via Pipelining):**
   * 将任务分解为多个阶段；多个任务可以同时处于执行的不同阶段，从而提高吞吐量。
6. **通过预测提高性能 (Performance via Prediction / Speculation):**
   * 猜测操作的结果（例如，分支方向）以继续执行而无需等待，如果猜错则纠正。
7. **使用分层存储器 (Use a Hierarchy of Memories):**
   * 采用多级存储器：小而快且昂贵的存储器（缓存）更靠近CPU，大而慢且便宜的存储器（主存、磁盘）则更远。
8. **通过冗余提高可靠性 (Improve Dependability via Redundancy):**
   * 包含冗余组件以检测并经常纠正故障。

### 为什么要学习体系结构？

理解“程序之下”的问题对现代程序员至关重要：

* **处理器的并行特性:** 如何利用线程/多处理加速应用；编译器如何为并行执行重排代码。
* **存储器的分层特性:** 内存访问模式如何影响性能；页面/缓存着色、伪共享、旁道攻击等概念。
* **高级语言到硬件指令的翻译:** 编译器在生成指令级语句过程中的决策。

---

## VI. 关键人物与历史背景

了解历史和重大进步背后的人物可以提供背景知识。

* **约翰·轩尼诗 (John L. Hennessy):**
  * MIPS 计算机系统公司联合创始人。
  * 斯坦福大学第十任校长。
  * 被马克·安德森称为“硅谷教父”。
* **大卫·帕特森 (David A. Patterson):**
  * 加州大学伯克利分校教授（自1976年起）。
  * RISC-V 基金会副主席。
  * 座右铭：“一次只做一件大事 (One big thing at a time)。”
* **轩尼诗与帕特森 (共同):**
  * **2017年图灵奖:** “表彰他们开创了一种系统化、定量的方法来设计和评估计算机体系结构，并对微处理器行业产生了持久影响。”
  * 有影响力的计算机体系结构教科书的作者。
* **弗雷德里克·布鲁克斯 (Frederick P. Brooks Jr.):**
  * **1999年ACM图灵奖:** 对计算机体系结构、操作系统和软件工程的里程碑式贡献。
  * **2004年艾克特-莫奇利奖 (Eckert-Mauchly Award):** 定义计算机体系结构、计算机家族概念、指令集设计原则（例如 IBM 360 ISA）。
  * 《人月神话》作者。
* **罗伯特·托马苏洛 (Robert Tomasulo):**
  * Tomasulo 算法的发明者。
  * **1997年艾克特-莫奇利奖:** 表彰其 Tomasulo 算法，使得乱序执行处理器得以实现。
* **西摩·克雷 (Seymour Cray):**
  * 超级计算机设计先驱（例如1958年第一台基于晶体管的超级计算机）。
  * 对 RISC 高端微处理器的贡献。
* **吉恩·阿姆达尔 (Gene M. Amdahl):**
  * 在流水线、指令预取、高速缓存存储器方面的创新。
  * 1950年设计了 WISC (威斯康星整体同步计算机)。
  * 提出了 **阿姆达尔定律**。
* **马特奥·瓦莱罗 (Mateo Valero):** 对指令级并行 (ILP) 和超标量处理器设计的贡献。
* **耶鲁·帕特 (Yale Patt):** 对指令级并行 (ILP) 和超标量处理器设计的贡献。
* **迈克尔·弗林 (Michael J. Flynn):**
  * 对处理器组织和分类 (费林分类法)、计算机算术、性能评估的贡献。

(ZJV 项目的具体历史请参考第二部分B节的ZJV项目时间线。)

---

## VII. 关键术语与概念

* **ISA (指令集架构 - Instruction Set Architecture):** 硬件和软件之间的契约。
* **微架构 (Microarchitecture):** ISA 的具体硬件实现。
* **冯诺依曼结构 (Von Neumann Architecture):** 指令和数据共享存储器的存储程序概念。
* **流水线 (Pipelining):** 将多条指令的执行在不同阶段重叠。
* **冒险 (Hazard - 流水线):** 阻止下一条指令在其指定时钟周期执行的情况 (结构冒险, 数据冒险, 控制冒险)。
* **转发 (Forwarding / Bypassing):** 一种通过将数据从生产阶段直接路由到消费阶段来解决数据冒险的方法。
* **分支预测 (Branch Prediction):** 猜测分支的结果以避免流水线停顿。
* **MMU (内存管理单元 - Memory Management Unit):** 处理虚拟地址到物理地址转换和内存保护的硬件。
* **TLB (快表/转换旁路缓冲器 - Translation Lookaside Buffer):** MMU 中用于缓存页表条目的高速缓存。
* **Cache (高速缓存):** 一种小型、快速的存储器，保存最近访问的数据，旨在加速对相同数据的后续访问。
* **虚拟内存 (Virtual Memory):** 一种技术，使每个进程都拥有自己独立的、巨大的地址空间的错觉，由操作系统和MMU管理。
* **分页 (Paging):** 一种常见的虚拟内存技术，将地址空间划分为固定大小的块，称为页。
* **SV39:** 一种 RISC-V 虚拟内存方案，使用39位虚拟地址和多级页表。
* **CSR (控制与状态寄存器 - Control and Status Registers):** RISC-V 中用于控制 CPU 行为和报告状态的特殊寄存器。
* **系统调用 (System Call):** 用户模式程序向操作系统内核请求服务的机制。
* **中断 (Interrupt):** 改变指令正常执行流程的事件（硬件或软件），通常用于处理紧急请求或错误。
* **异常 (Exception):** 程序执行期间发生的扰乱正常流程的意外事件（例如，非法指令、缺页）。
* **ILP (指令级并行 - Instruction-Level Parallelism):** 并行执行单个程序中多条指令的潜力。
* **DLP (数据级并行 - Data-Level Parallelism):** 同时对多个数据元素执行相同操作（例如，SIMD）。
* **TLP (线程级并行 - Thread-Level Parallelism):** 并发执行多个执行线程。
* **Chisel:** 嵌入在 Scala 中的硬件构建语言。
* **Verilog/VHDL:** 硬件描述语言 (HDL)。
* **FPGA (现场可编程门阵列 - Field-Programmable Gate Array):** 一种集成电路，可以在制造后由设计者配置。
* **ASIC (专用集成电路 - Application-Specific Integrated Circuit):** 为特定用途而非通用目的设计的芯片。
* **流片 (Tape-out):** 集成电路设计在制造前的最后阶段。
* **摩尔定律 (Moore's Law):** 关于微芯片上晶体管数量大约每两年翻一番的观察。
* **阿姆达尔定律 (Amdahl's Law):** 一个公式，给出在固定工作负载下，改进系统资源可以预期任务执行延迟的理论加速。
* **CPU 时间 (CPU Time):** CPU 积极处理任务的时间。
* **时钟频率 (Clock Rate):** 微处理器执行指令的速度，以每秒周期数（赫兹）为单位。
* **CPI (每指令周期数 - Cycles Per Instruction):** 每条指令的平均时钟周期数。
* **IC (指令数 - Instruction Count):** 程序执行的总指令数。
* **响应时间 (Response Time / Latency - 延迟):** 系统对给定输入做出反应所花费的时间。
* **吞吐量 (Throughput):** 系统在给定时期内可以完成的工作量。

---

## VIII. 问答/潜在考点

1. **问：解释冯诺依曼结构。它的关键组成部分和原理是什么？**
   * 答：数据和程序在共享内存中；CPU（控制器、运算器）、内存、I/O、存储器；取指-译码-执行周期。
2. **问：计算机体系结构的八个伟大思想是什么？列出并简要描述其中三个。**
   * 答：为摩尔定律设计、使用抽象、重点优化常用部分、通过并行提高性能、通过流水线提高性能、通过预测提高性能、使用分层存储器、通过冗余提高可靠性。
3. **问：使用其基本组成部分（IC、CPI、时钟周期时间/频率）定义 CPU 时间。**
   * 答：CPU 时间 = IC × CPI × 时钟周期时间  或  CPU 时间 = (IC × CPI) / 时钟频率。
4. **问：陈述阿姆达尔定律。如果一项程序增强将程序 60% 的部分加速了 3 倍，那么整体加速比是多少？**
   * 答：整体加速比 = 1 / [ (1 - 增强部分占比) + (增强部分占比 / 增强带来的加速比) ]。
     增强部分占比 = 0.6, 增强带来的加速比 = 3。
     加速比 = 1 / [(1 - 0.6) + (0.6 / 3)] = 1 / [0.4 + 0.2] = 1 / 0.6 ≈ 1.67。
5. **问：描述 ISA 和微架构之间的区别。**
   * 答：ISA 是计算机的抽象模型（软件接口），微架构是该 ISA 的具体硬件实现。
6. **问：设计流水线 CPU 的主要挑战是什么？至少提及两种类型的冒险。**
   * 答：处理冒险：结构冒险、数据冒险（RAW、WAR、WAW）、控制冒险。确保正确的数据转发和分支预测。
7. **问：解释 MMU 和 TLB 在虚拟内存系统中的作用。**
   * 答：MMU 将虚拟地址转换为物理地址并实施内存保护。TLB 是用于最近转换的缓存，以加速该过程。
8. **问：浙江大学的 ZJV 项目和“系统贯通课程”有何意义？**
   * 答：强调动手学习，使学生能够设计和构建自己的 CPU 和操作系统，弥合理论与实践之间的差距。ZJV 展示了学生主导的成功的 RISC-V 开发和流片。
9. **问：区分响应时间和吞吐量。举一个可能优先考虑其中一个而不是另一个的例子。**
   * 答：响应时间：单个任务的延迟（交互式应用）。吞吐量：单位时间内完成的总工作量（服务器工作负载）。
10. **问：约翰·轩尼诗和大卫·帕特森是谁？他们因哪项重大贡献获得了图灵奖？**
    * 答：计算机体系结构的先驱，分别对 MIPS 和 RISC-V 有贡献。因其对计算机体系结构设计和评估的系统化、定量方法而获得图灵奖。

---

## IX. 总结

* **成本/性能持续改进**，受底层技术发展（摩尔定律）驱动。
* **分层抽象**在硬件和软件中对于管理复杂性都至关重要。
* **指令集架构 (ISA)** 是关键的硬件/软件接口。
* **执行时间**是衡量性能的最佳单一指标。
* **八个伟大的体系结构思想**为理解和设计高效计算机系统提供了框架。
* 最终目标不仅仅是学习系统，而是能够**构建你自己的系统**。
